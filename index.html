<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- viewport-fit=cover を追加して全画面表示時のSafe Area対応を有効化 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>バスケットボール作戦盤 Pro (オフライン版)</title>
    <style>
        :root {
            --bg-color: #1a202c;
            --header-bg: #1f2937;
            --panel-bg: #2d3748;
            --text-color: #ffffff;
            --accent-color: #e38d47;
            --blue-btn: #2563eb;
            --blue-btn-hover: #1d4ed8;
            --red-btn: #dc2626;
            --green-btn: #16a34a;
            --gray-btn: #4b5563;
        }

        * {
            box-sizing: border-box;
        }

        html {
            height: 100%;
            overflow: hidden; /* HTMLレベルでもスクロール禁止 */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            
            /* --- iOS Safari 修正箇所 --- */
            /* フォールバックとしての100vh */
            height: 100vh;
            /* モダンブラウザ(iOS Safari含む)向けの動的高さ指定 */
            height: 100dvh;
            
            /* 画面位置を固定してスクロールやバーの影響を最小化 */
            width: 100%;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            /* ------------------------- */

            display: flex;
            flex-direction: column;
            overflow: hidden;
            touch-action: none;
            overscroll-behavior: none;
        }

        /* Icons (SVG) */
        .icon {
            width: 1em;
            height: 1em;
            display: inline-block;
            vertical-align: middle;
            fill: currentColor;
        }

        /* Header */
        header {
            background-color: var(--header-bg);
            padding: 0.5rem 1rem;
            /* 上部のSafe Area対応（ノッチがある場合など） */
            padding-top: calc(0.5rem + env(safe-area-inset-top));
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: auto;
            min-height: 56px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
            flex-shrink: 0; /* ヘッダーが縮まないように */
        }

        .title-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h1 {
            margin: 0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .court-switch {
            background-color: #111827;
            padding: 2px;
            border-radius: 4px;
            display: flex;
        }

        .court-switch button {
            background: none;
            border: none;
            color: #9ca3af;
            padding: 4px 12px;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
        }

        .court-switch button.active {
            background-color: var(--gray-btn);
            color: white;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .btn {
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s;
        }

        .btn-gray { background-color: var(--gray-btn); }
        .btn-gray:hover { background-color: #374151; }
        .btn-blue { background-color: var(--blue-btn); font-weight: bold; }
        .btn-blue:hover { background-color: var(--blue-btn-hover); }
        .btn-green { background-color: var(--green-btn); font-weight: bold; }
        .btn-red { background-color: var(--red-btn); }

        /* Main Area */
        main {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #111827;
            padding: 8px;
            overflow: hidden;
            width: 100%; /* 幅を明示 */
        }

        #canvas-container {
            position: relative;
            background-color: var(--accent-color);
            border-radius: 4px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #frame-overlay {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
        }

        #trash-zone {
            position: absolute;
            bottom: 16px;
            right: 16px;
            width: 60px;
            height: 60px;
            background-color: rgba(220, 38, 38, 0.8);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s;
            transform: scale(0.8);
            z-index: 20;
        }

        #trash-zone.visible {
            opacity: 0.5;
            pointer-events: auto;
        }
        #trash-zone.active {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Footer / Controls */
        footer {
            background-color: var(--header-bg);
            padding: 8px;
            /* 下部のSafe Area対応（iPhoneのホームバーなど） */
            padding-bottom: calc(8px + env(safe-area-inset-bottom));
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
            z-index: 10;
            flex-shrink: 0; /* フッターが縮まないように */
        }

        .controls-container {
            max-width: 800px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tool-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(55, 65, 81, 0.5);
            padding: 6px;
            border-radius: 8px;
        }

        .tool-group {
            display: flex;
            gap: 4px;
        }

        .icon-btn {
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 1rem;
        }
        .icon-btn:active { transform: scale(0.95); }

        .piece-row {
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 4px;
        }

        .mode-switch {
            display: flex;
            background-color: var(--gray-btn);
            border-radius: 6px;
            padding: 2px;
        }
        .mode-switch button {
            background: none;
            border: none;
            color: #9ca3af;
            padding: 6px 16px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .mode-switch button.active {
            background-color: var(--blue-btn);
            color: white;
            font-weight: bold;
        }

        .piece-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.9rem;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .piece-red { background-color: var(--red-btn); color: white; }
        .piece-blue { background-color: var(--blue-btn); color: white; }
        .piece-ball { background-color: #f97316; color: black; }

        /* Dialog */
        dialog {
            background: var(--panel-bg);
            color: white;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 0;
            width: 90%;
            max-width: 400px;
        }
        dialog::backdrop {
            background: rgba(0,0,0,0.6);
        }
        .dialog-header {
            padding: 1rem;
            background: #1a202c;
            border-bottom: 1px solid #4a5568;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .close-btn {
            background: none;
            border: none;
            color: #a0aec0;
            cursor: pointer;
            font-size: 1.2rem;
        }
        .dialog-body {
            padding: 1rem;
            max-height: 60vh;
            overflow-y: auto;
        }
        input[type="text"] {
            width: 100%;
            background: #4a5568;
            border: 1px solid #718096;
            color: white;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 1rem;
        }
        .save-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #4a5568;
            margin-bottom: 8px;
            border-radius: 4px;
            cursor: pointer;
        }
        .save-item:hover { background: #556070; }
        .save-info { flex: 1; }
        .save-name { font-weight: bold; color: #90cdf4; font-size: 0.9rem; }
        .save-date { font-size: 0.75rem; color: #cbd5e0; }

        /* Utilities */
        .hidden { display: none !important; }
        @media (max-width: 600px) {
            .hide-sm { display: none; }
            h1 { font-size: 0.9rem; }
            .btn { padding: 6px 8px; }
        }
    </style>
</head>
<body>

    <!-- SVG Definitions -->
    <svg style="display: none;">
        <symbol id="icon-ball" viewBox="0 0 512 512">
            <path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm-6.5 28.5c2.2 0 4.3.1 6.5.3v155c-112.5 0-209.6-67.6-252.8-164.7 65.5-44.3 144.3-70.6 229.8-70.6zm-24 183.5v262c-85.5 0-164.3-26.3-229.8-70.6 43.2-97.1 140.3-164.7 252.8-164.7zm24-26.6V38.8c85.5 44.3 144.3 133.4 144.3 236.2 0 102.8-58.8 191.9-144.3 236.2V193.4zM497.5 224h-155c-2.2-76.8-29.3-148.5-74.8-205.7 101.5 16.3 186.7 87 229.8 179.7zM267.7 493.7c45.5-57.2 72.6-128.9 74.8-205.7h155c-43.1 92.7-128.3 163.4-229.8 179.7z"/>
        </symbol>
        <symbol id="icon-folder" viewBox="0 0 512 512">
            <path d="M464 128H272l-64-64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V176c0-26.51-21.49-48-48-48z"/>
        </symbol>
        <symbol id="icon-save" viewBox="0 0 448 512">
            <path d="M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"/>
        </symbol>
        <symbol id="icon-trash" viewBox="0 0 448 512">
            <path d="M32 464a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128H32zm272-256a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zM432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z"/>
        </symbol>
        <symbol id="icon-undo" viewBox="0 0 512 512">
            <path d="M212.333 224.333H12c-6.627 0-12-5.373-12-12V12C0 5.373 5.373 0 12 0h48c6.627 0 12 5.373 12 12v78.112C117.773 39.279 184.26 7.47 258.175 8.007c136.906.994 246.448 111.623 246.157 248.532C504.041 393.258 393.12 504 256.333 504c-64.089 0-122.496-24.313-166.51-64.215-5.099-4.622-5.334-12.554-.467-17.42l33.967-33.967c4.474-4.474 11.662-4.717 16.401-.525C170.76 415.336 211.58 432 256.333 432c97.268 0 176-78.716 176-176 0-97.267-78.716-176-176-176-58.496 0-110.28 28.476-142.274 72.333h98.274c6.627 0 12 5.373 12 12v48c0 6.627-5.373 12-12 12z"/>
        </symbol>
        <symbol id="icon-play" viewBox="0 0 448 512">
            <path d="M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z"/>
        </symbol>
        <symbol id="icon-stop" viewBox="0 0 448 512">
            <path d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"/>
        </symbol>
        <symbol id="icon-plus" viewBox="0 0 512 512">
            <path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"/>
        </symbol>
        <symbol id="icon-check" viewBox="0 0 512 512">
            <path d="M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"/>
        </symbol>
        <symbol id="icon-arrows" viewBox="0 0 512 512">
            <path d="M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"/>
        </symbol>
        <symbol id="icon-pen" viewBox="0 0 512 512">
            <path d="M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z"/>
        </symbol>
        <symbol id="icon-times" viewBox="0 0 352 512">
            <path d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"/>
        </symbol>
    </svg>

    <!-- Header -->
    <header>
        <div class="title-group">
            <h1>
                <svg class="icon" style="color: var(--accent-color);"><use href="#icon-ball"></use></svg>
                <span class="hide-sm">Tactics Pro V4</span>
            </h1>
            <div class="court-switch">
                <button onclick="setCourtType('full')" id="btn-court-full" class="active">Full</button>
                <button onclick="setCourtType('half')" id="btn-court-half">Half</button>
            </div>
        </div>

        <div class="header-actions">
            <button onclick="openLoadModal()" class="btn btn-gray">
                <svg class="icon"><use href="#icon-folder"></use></svg> <span class="hide-sm">読込</span>
            </button>
            <button onclick="openSaveModal()" class="btn btn-blue">
                <svg class="icon"><use href="#icon-save"></use></svg> <span class="hide-sm">保存</span>
            </button>
        </div>
    </header>

    <!-- Main Canvas Area -->
    <main id="main-area">
        <div id="canvas-container">
            <canvas id="board"></canvas>
            <div id="frame-overlay">
                Frame: 0
            </div>
        </div>
        
        <!-- ゴミ箱 -->
        <div id="trash-zone">
            <svg class="icon"><use href="#icon-trash"></use></svg>
        </div>
    </main>

    <!-- Controls -->
    <footer>
        <div class="controls-container">
            <div class="tool-row">
                <div class="tool-group">
                    <button onclick="clearAll()" class="icon-btn btn-red" title="全消去">
                        <svg class="icon"><use href="#icon-trash"></use></svg>
                    </button>
                    <button onclick="undo()" class="icon-btn btn-gray" title="ひとつ戻る">
                        <svg class="icon"><use href="#icon-undo"></use></svg>
                    </button>
                </div>

                <div class="tool-group">
                    <button id="add-frame-btn" onclick="addFrame()" class="btn btn-green">
                        <svg class="icon"><use href="#icon-plus"></use></svg> 場面追加
                    </button>
                    <button id="play-btn" onclick="togglePlay()" class="btn btn-blue" style="min-width: 80px;">
                        <svg class="icon"><use href="#icon-play"></use></svg> 再生
                    </button>
                </div>
            </div>

            <div class="piece-row">
                <div class="mode-switch">
                    <button id="mode-move" onclick="setMode('move')" class="active">
                        <svg class="icon"><use href="#icon-arrows"></use></svg> 移動
                    </button>
                    <button id="mode-draw" onclick="setMode('draw')">
                        <svg class="icon"><use href="#icon-pen"></use></svg> 線
                    </button>
                </div>
                <div style="border-left: 1px solid #4b5563; margin: 0 8px;"></div>
                <div class="tool-group">
                    <button onclick="addPiece('red')" class="piece-btn piece-red">A</button>
                    <button onclick="addPiece('blue')" class="piece-btn piece-blue">B</button>
                    <button onclick="addPiece('ball')" class="piece-btn piece-ball">
                        <svg class="icon"><use href="#icon-ball"></use></svg>
                    </button>
                </div>
            </div>
        </div>
    </footer>

    <!-- Save Modal -->
    <dialog id="save-modal">
        <div class="dialog-header">
            <span>名前をつけて保存</span>
            <button onclick="document.getElementById('save-modal').close()" class="close-btn">
                <svg class="icon"><use href="#icon-times"></use></svg>
            </button>
        </div>
        <div class="dialog-body">
            <label style="display:block; margin-bottom:4px; font-size:0.8rem; color:#a0aec0;">作戦名</label>
            <input type="text" id="save-name-input" placeholder="例: セットオフェンスA">
            <button onclick="saveData()" class="btn btn-blue" style="width:100%; justify-content:center;">
                保存する
            </button>
        </div>
    </dialog>

    <!-- Load Modal -->
    <dialog id="load-modal">
        <div class="dialog-header">
            <span>保存された作戦</span>
            <button onclick="document.getElementById('load-modal').close()" class="close-btn">
                <svg class="icon"><use href="#icon-times"></use></svg>
            </button>
        </div>
        <div class="dialog-body" id="load-list">
            <p style="text-align:center; color:#718096;">保存データなし</p>
        </div>
    </dialog>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const trashZone = document.getElementById('trash-zone');
        const frameOverlay = document.getElementById('frame-overlay');

        const COURT_COLOR = '#e38d47';
        const LINE_COLOR = '#ffffff';
        const PIECE_RADIUS_METER = 0.5;
        
        let pieces = [];
        let drawings = [];
        let frames = [];
        
        let mode = 'move';
        let courtType = 'full';
        let isDragging = false;
        let selectedPiece = null;
        let currentPath = null;
        
        let isPlaying = false;
        let animationTime = 0;
        let currentFrameIndex = 0;
        let history = []; 

        let ppm = 0; // pixels per meter (CSS pixels)
        let originX = 0;
        let originY = 0;

        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // タッチとマウスの正規化
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('mouseleave', handleEnd);
            
            // passive: false でスクロール防止
            canvas.addEventListener('touchstart', (e) => handleStart(e.touches[0], e), {passive: false});
            canvas.addEventListener('touchmove', (e) => handleMove(e.touches[0], e), {passive: false});
            canvas.addEventListener('touchend', handleEnd);

            requestAnimationFrame(loop);
        }

        function resize() {
            const mainArea = document.getElementById('main-area');
            const maxWidth = mainArea.clientWidth - 16;
            const maxHeight = mainArea.clientHeight - 16;
            
            let targetAspect;
            if (courtType === 'full') {
                targetAspect = 28 / 15;
            } else {
                targetAspect = 14.5 / 15; 
            }

            let w = maxWidth;
            let h = w / targetAspect;
            
            if (h > maxHeight) {
                h = maxHeight;
                w = h * targetAspect;
            }

            const dpr = window.devicePixelRatio || 1;
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            canvas.style.width = `${w}px`;
            canvas.style.height = `${h}px`;
            
            ctx.scale(dpr, dpr);
            
            window.canvasWidth = w;
            window.canvasHeight = h;
            
            if (courtType === 'full') {
                ppm = w / 28;
            } else {
                ppm = w / 14.5;
            }
        }

        function setCourtType(type) {
            courtType = type;
            document.getElementById('btn-court-full').className = type === 'full' ? "active" : "";
            document.getElementById('btn-court-half').className = type === 'half' ? "active" : "";
            resize();
        }

        function drawCourt() {
            const w = window.canvasWidth;
            const h = window.canvasHeight;
            
            ctx.fillStyle = COURT_COLOR;
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = LINE_COLOR;
            ctx.lineWidth = Math.max(1.5, 2 * (ppm / 25));
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const courtHeightM = 15;
            const offsetY = (h - (courtHeightM * ppm)) / 2;

            ctx.save();
            ctx.translate(0, offsetY);

            if (courtType === 'full') {
                ctx.strokeRect(0, 0, 28 * ppm, 15 * ppm);
                
                ctx.beginPath();
                ctx.moveTo(14 * ppm, 0);
                ctx.lineTo(14 * ppm, 15 * ppm);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(14 * ppm, 7.5 * ppm, 1.8 * ppm, 0, Math.PI * 2);
                ctx.stroke();

                drawKeyArea(0, false);
                drawKeyArea(28, true);
            } else {
                ctx.strokeRect(0, 0, 14 * ppm, 15 * ppm);
                
                ctx.beginPath();
                ctx.moveTo(14 * ppm, 0);
                ctx.lineTo(14 * ppm, 15 * ppm);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(14 * ppm, 7.5 * ppm, 1.8 * ppm, Math.PI * 0.5, Math.PI * 1.5);
                ctx.stroke();

                drawKeyArea(0, false);
            }
            ctx.restore();
        }

        function drawKeyArea(offsetX, isRight) {
            const dir = isRight ? -1 : 1;
            const baseX = offsetX * ppm;
            const centerY = 7.5 * ppm;

            const kHoopCenterDist = 1.575; 
            const kHoopRadius = 0.225; 
            const kBackboardDist = 1.2; 
            const kKeyWidth = 4.9;
            const kKeyDepth = 5.8; 
            const k3ptRadius = 6.75; 
            const kNoChargeRadius = 1.25;

            // 1. 制限区域
            const kw = kKeyWidth * ppm;
            const kd = kKeyDepth * ppm;
            const keyX = isRight ? baseX - kd : baseX;
            const keyY = centerY - (kw / 2);
            ctx.strokeRect(keyX, keyY, kd, kw);

            // 2. フリースローサークル
            const ftCenterX = baseX + (dir * 5.8 * ppm);
            ctx.beginPath();
            ctx.arc(ftCenterX, centerY, 1.8 * ppm, 0, Math.PI * 2);
            ctx.stroke();

            // 3. バックボード & リング
            const boardX = baseX + (dir * kBackboardDist * ppm);
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#fff'; 
            ctx.beginPath();
            ctx.moveTo(boardX, centerY - (0.9 * ppm));
            ctx.lineTo(boardX, centerY + (0.9 * ppm));
            ctx.stroke();

            const hoopX = baseX + (dir * kHoopCenterDist * ppm);
            ctx.strokeStyle = '#ea580c';
            ctx.beginPath();
            ctx.arc(hoopX, centerY, kHoopRadius * ppm, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = '#ea580c';
            ctx.beginPath();
            ctx.moveTo(boardX, centerY);
            ctx.lineTo(isRight ? hoopX + (kHoopRadius * ppm) : hoopX - (kHoopRadius * ppm), centerY);
            ctx.stroke();

            // 4. ノーチャージセミサークル
            ctx.strokeStyle = LINE_COLOR;
            ctx.lineWidth = Math.max(1.5, 2 * (ppm / 25));

            ctx.beginPath();
            if (isRight) {
                ctx.arc(hoopX, centerY, kNoChargeRadius * ppm, Math.PI * 0.5, Math.PI * 1.5, false);
            } else {
                ctx.arc(hoopX, centerY, kNoChargeRadius * ppm, -Math.PI * 0.5, Math.PI * 0.5, false);
            }
            ctx.stroke();

            // 5. 3ポイントライン
            const r3 = k3ptRadius * ppm;
            const cornerMargin = 0.9 * ppm; 
            const topY = cornerMargin;
            const bottomY = (15 * ppm) - cornerMargin;

            const angle = Math.atan2(6.6, Math.sqrt(Math.pow(6.75, 2) - Math.pow(6.6, 2)));
            const dx = Math.abs(Math.cos(angle) * r3);
            const arcStartX = hoopX + (dir * dx);

            ctx.beginPath();
            ctx.moveTo(baseX, topY);
            ctx.lineTo(arcStartX, topY);

            if (isRight) {
                ctx.arc(hoopX, centerY, r3, Math.PI + angle, Math.PI - angle, true);
            } else {
                ctx.arc(hoopX, centerY, r3, -angle, angle, false);
            }

            ctx.lineTo(baseX, bottomY);
            ctx.stroke();
        }

        function drawPieces(renderPieces) {
            const courtHeightM = 15;
            const offsetY = (window.canvasHeight - (courtHeightM * ppm)) / 2;

            renderPieces.forEach(p => {
                let drawX, drawY;

                if (p.unit === 'meter') {
                    drawX = p.x * ppm;
                    drawY = p.y * ppm + offsetY;
                } else {
                    drawX = p.x;
                    drawY = p.y + offsetY;
                }
                
                ctx.beginPath();
                ctx.shadowColor = 'rgba(0,0,0,0.4)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetY = 2;

                const r = (PIECE_RADIUS_METER * ppm);

                if (p.type === 'ball') {
                    ctx.fillStyle = '#f97316';
                    ctx.arc(drawX, drawY, r * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else {
                    ctx.fillStyle = p.type === 'red' ? '#dc2626' : '#2563eb';
                    ctx.arc(drawX, drawY, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    ctx.shadowColor = 'transparent';
                    ctx.fillStyle = 'white';
                    ctx.font = `bold ${Math.max(10, r)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.label, drawX, drawY);
                }
                ctx.shadowColor = 'transparent';
            });
        }

        function drawDrawings(renderDrawings) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const courtHeightM = 15;
            const offsetY = (window.canvasHeight - (courtHeightM * ppm)) / 2;

            renderDrawings.forEach(d => {
                if (d.points.length < 2) return;
                
                ctx.beginPath();
                ctx.strokeStyle = d.color || '#facc15';
                ctx.lineWidth = 3;
                
                const getPx = (pt) => {
                    if (pt.unit === 'meter') {
                        return { x: pt.x * ppm, y: pt.y * ppm + offsetY };
                    }
                    return { x: pt.x, y: pt.y + offsetY };
                };

                const start = getPx(d.points[0]);
                ctx.moveTo(start.x, start.y);
                
                for (let i = 1; i < d.points.length; i++) {
                    const pt = getPx(d.points[i]);
                    ctx.lineTo(pt.x, pt.y);
                }
                ctx.stroke();

                const last = getPx(d.points[d.points.length - 1]);
                const prev = getPx(d.points[d.points.length - 2]);
                if(last && prev){
                    const angle = Math.atan2(last.y - prev.y, last.x - prev.x);
                    ctx.beginPath();
                    ctx.moveTo(last.x, last.y);
                    ctx.lineTo(last.x - 12 * Math.cos(angle - Math.PI / 6), last.y - 12 * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(last.x - 12 * Math.cos(angle + Math.PI / 6), last.y - 12 * Math.sin(angle + Math.PI / 6));
                    ctx.fillStyle = d.color || '#facc15';
                    ctx.fill();
                }
            });
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCourt();

            if (isPlaying) {
                updateAnimation();
            } else {
                drawDrawings(drawings);
                drawPieces(pieces);
            }
            requestAnimationFrame(loop);
        }

        function getMeterPos(e) {
            const rect = canvas.getBoundingClientRect();
            const pxX = e.clientX - rect.left;
            const pxY = e.clientY - rect.top;
            
            const courtHeightM = 15;
            const offsetY = (window.canvasHeight - (courtHeightM * ppm)) / 2;
            
            return {
                x: pxX / ppm,
                y: (pxY - offsetY) / ppm,
                unit: 'meter'
            };
        }

        function getDistM(p1, p2) {
            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        }

        function handleStart(e, originalEvent) {
            if (originalEvent) {
                if (originalEvent.touches && originalEvent.touches.length > 0) {
                    e = originalEvent.touches[0];
                } else if (!e.clientX && originalEvent.clientX) {
                    e = originalEvent;
                }
                originalEvent.preventDefault();
            }
            
            if (isPlaying) return;

            const mPos = getMeterPos(e);
            isDragging = true;

            if (mode === 'move') {
                for (let i = pieces.length - 1; i >= 0; i--) {
                    const p = pieces[i];
                    if (getDistM(p, mPos) <= PIECE_RADIUS_METER * 1.5) {
                        selectedPiece = p;
                        trashZone.classList.add('visible');
                        saveToHistory();
                        return;
                    }
                }
            } else if (mode === 'draw') {
                currentPath = { color: '#facc15', points: [mPos] };
                drawings.push(currentPath);
                saveToHistory();
            }
        }

        function handleMove(e, originalEvent) {
            if (originalEvent) {
                if (originalEvent.touches && originalEvent.touches.length > 0) {
                    e = originalEvent.touches[0];
                }
                originalEvent.preventDefault();
            }
            if (!isDragging) return;

            const mPos = getMeterPos(e);

            if (mode === 'move' && selectedPiece) {
                selectedPiece.x = mPos.x;
                selectedPiece.y = mPos.y;
                
                // ゴミ箱判定
                const clientX = e.clientX;
                const clientY = e.clientY;
                const trashRect = trashZone.getBoundingClientRect();
                
                if (clientX >= trashRect.left && clientX <= trashRect.right &&
                    clientY >= trashRect.top && clientY <= trashRect.bottom) {
                      trashZone.classList.add('active');
                } else {
                      trashZone.classList.remove('active');
                }

            } else if (mode === 'draw' && currentPath) {
                currentPath.points.push(mPos);
            }
        }

        function handleEnd(e) {
            isDragging = false;
            
            if (mode === 'move' && selectedPiece) {
                if (trashZone.classList.contains('active')) {
                    pieces = pieces.filter(p => p !== selectedPiece);
                }

                trashZone.classList.remove('visible', 'active');
                selectedPiece = null;
            }
            if (mode === 'draw') currentPath = null;
        }

        function setMode(m) {
            mode = m;
            document.getElementById('mode-move').className = m === 'move' ? "active" : "";
            document.getElementById('mode-draw').className = m === 'draw' ? "active" : "";
        }

        function addPiece(type) {
            saveToHistory();
            const id = Date.now() + Math.random();
            const label = type === 'ball' ? '' : (pieces.filter(p => p.type === type).length + 1).toString();
            
            const centerX = courtType === 'full' ? 14 : 7;
            const centerY = 7.5;

            pieces.push({
                id: id,
                type: type,
                x: centerX + (Math.random() * 2 - 1),
                y: centerY + (Math.random() * 2 - 1),
                label: label,
                unit: 'meter'
            });
        }

        function clearAll() {
            if(confirm('すべて消去しますか？')) {
                pieces = [];
                drawings = [];
                frames = [];
                currentFrameIndex = 0;
                updateFrameIndicator();
            }
        }

        function undo() {
            if (history.length > 0) {
                const state = history.pop();
                pieces = JSON.parse(state.pieces);
                drawings = JSON.parse(state.drawings);
            }
        }

        function saveToHistory() {
            if (history.length > 20) history.shift();
            history.push({ pieces: JSON.stringify(pieces), drawings: JSON.stringify(drawings) });
        }

        function addFrame() {
            frames.push({
                pieces: JSON.parse(JSON.stringify(pieces)),
                drawings: JSON.parse(JSON.stringify(drawings))
            });
            currentFrameIndex = frames.length;
            updateFrameIndicator();
            
            const btn = document.getElementById('add-frame-btn');
            const originalText = '場面追加';
            btn.innerHTML = '<svg class="icon"><use href="#icon-check"></use></svg> 追加';
            setTimeout(() => btn.innerHTML = '<svg class="icon"><use href="#icon-plus"></use></svg> ' + originalText, 500);
        }

        function togglePlay() {
            if (frames.length < 2) return;
            isPlaying = !isPlaying;
            const btn = document.getElementById('play-btn');
            
            if (isPlaying) {
                btn.innerHTML = '<svg class="icon"><use href="#icon-stop"></use></svg> 停止';
                btn.style.backgroundColor = '#ea580c'; // orange
                currentFrameIndex = 0;
                animationTime = 0;
            } else {
                btn.innerHTML = '<svg class="icon"><use href="#icon-play"></use></svg> 再生';
                btn.style.backgroundColor = '#2563eb'; // blue
                if(frames.length > 0) {
                    const last = frames[frames.length - 1];
                    pieces = JSON.parse(JSON.stringify(last.pieces));
                    drawings = JSON.parse(JSON.stringify(last.drawings));
                }
            }
        }

        function updateAnimation() {
            if (currentFrameIndex >= frames.length - 1) {
                togglePlay();
                return;
            }
            const start = frames[currentFrameIndex];
            const end = frames[currentFrameIndex + 1];
            
            animationTime += 0.02;

            if (animationTime >= 1) {
                animationTime = 0;
                currentFrameIndex++;
            }

            drawDrawings(start.drawings);

            const interpolated = start.pieces.map(s => {
                const e = end.pieces.find(p => p.id === s.id);
                if (!e) return s;
                const t = animationTime > 1 ? 1 : animationTime;
                const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                return {
                    ...s,
                    x: s.x + (e.x - s.x) * ease,
                    y: s.y + (e.y - s.y) * ease
                };
            });
            drawPieces(interpolated);
            frameOverlay.textContent = `Play: ${currentFrameIndex + 1} / ${frames.length}`;
        }

        function updateFrameIndicator() {
            frameOverlay.textContent = `Frame: ${frames.length}`;
        }

        const STORAGE_KEY = 'basketball_board_v3_data';

        function openSaveModal() {
            document.getElementById('save-modal').showModal();
        }

        function openLoadModal() {
            updateLoadList();
            document.getElementById('load-modal').showModal();
        }

        function saveData() {
            const nameInput = document.getElementById('save-name-input');
            const name = nameInput.value.trim();
            if (!name) return;

            const dataToSave = {
                name: name,
                date: new Date().toLocaleString(),
                pieces: pieces,
                drawings: drawings,
                frames: frames,
                courtType: courtType
            };

            let allData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
            allData[name] = dataToSave;
            localStorage.setItem(STORAGE_KEY, JSON.stringify(allData));

            alert(`保存しました`);
            nameInput.value = '';
            document.getElementById('save-modal').close();
        }

        function updateLoadList() {
            const listEl = document.getElementById('load-list');
            const allData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
            const names = Object.keys(allData);

            if (names.length === 0) {
                listEl.innerHTML = '<p style="text-align:center; color:#718096; padding:1rem;">保存データなし</p>';
                return;
            }

            listEl.innerHTML = '';
            names.forEach(name => {
                const item = allData[name];
                const div = document.createElement('div');
                div.className = 'save-item';
                div.innerHTML = `
                    <div class="save-info" onclick="loadData('${name}')">
                        <div class="save-name">${name}</div>
                        <div class="save-date">${item.date}</div>
                    </div>
                    <button onclick="deleteData('${name}')" style="background:none; border:none; color:#fc8181; cursor:pointer; padding:8px;">
                        <svg class="icon"><use href="#icon-trash"></use></svg>
                    </button>
                `;
                listEl.appendChild(div);
            });
        }

        function loadData(name) {
            if(!confirm('現在の作業内容は失われます。読み込みますか？')) return;
            const allData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
            const data = allData[name];
            if (data) {
                pieces = data.pieces || [];
                drawings = data.drawings || [];
                frames = data.frames || [];
                if (data.courtType) setCourtType(data.courtType);
                currentFrameIndex = 0;
                updateFrameIndicator();
                document.getElementById('load-modal').close();
            }
        }

        function deleteData(name) {
            if(!confirm('削除しますか？')) return;
            let allData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
            delete allData[name];
            localStorage.setItem(STORAGE_KEY, JSON.stringify(allData));
            updateLoadList();
        }

        window.onload = init;
    </script>
</body>
</html>
